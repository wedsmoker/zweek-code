#include "coder/tiny_coder.hpp"
#include <sstream>
#include <iostream>
#include <regex>

namespace zweek {
namespace coder {

TinyCoder::TinyCoder() {}
TinyCoder::~TinyCoder() { UnloadModel(); }

bool TinyCoder::LoadModel(const std::string &model_path) {
  // Use a smaller context for the tiny model if possible, or standard 2048
  model_loaded_ = model_loader_.Load(model_path, 2048);
  return model_loaded_;
}

void TinyCoder::UnloadModel() {
  model_loader_.Unload();
  model_loaded_ = false;
}

std::string TinyCoder::ConstructPrompt(const std::string &instruction,
                                       const std::vector<std::string> &files) {
  std::stringstream ss;
  ss << "<fim_prefix>";
  
  // Add file context
  for (const auto &file : files) {
    // In a real implementation, we'd read the file content here.
    // For now, we assume the 'files' vector contains the content or we need a way to read it.
    // Wait, the API signature takes vector<string> files. 
    // Let's assume these are file PATHS and we need to read them, 
    // OR they are file CONTENTS. 
    // Given the complexity, let's assume the caller passes file CONTENTS or formatted context.
    // Let's assume 'files' contains "Filename: ...\nContent: ..." strings for now.
    ss << file << "\n\n";
  }

  ss << "Instruction: " << instruction << "\n";
  ss << "Output the code changes required to fulfill the instruction.\n";
  ss << "<fim_suffix><fim_middle>";
  return ss.str();
}

std::vector<CodeEdit> TinyCoder::GenerateEdits(const std::string &instruction,
                                               const std::vector<std::string> &files,
                                               std::function<void(const std::string &)> stream_callback,
                                               std::atomic<bool>* interrupt_flag) {
  if (!model_loaded_) {
    LoadModel("models/starcoder-tiny.gguf");
  }

  if (!model_loaded_) {
    return {};
  }

  std::string prompt = ConstructPrompt(instruction, files);
  
  // Run inference
  std::string response = model_loader_.Infer(prompt, "", 2048, stream_callback, interrupt_flag);

  // Parse response into CodeEdit objects
  // This is a simplified parser. Real-world would need robust parsing of diffs/blocks.
  std::vector<CodeEdit> edits;
  
  // Mock parsing for now - we'll assume the model outputs the whole file content or a clear block
  // For this iteration, let's just wrap the whole response as one edit to the first file (if any)
  if (!files.empty()) {
      CodeEdit edit;
      // Extract filename from the first file string if possible, or just use a placeholder
      // Assuming the first string in 'files' has the filename.
      // This is a bit hacky, but sufficient for the prototype.
      edit.file_path = "generated_code.cpp"; 
      edit.new_content = response;
      edit.explanation = "Generated by TinyCoder";
      edits.push_back(edit);
  }

  return edits;
}

} // namespace coder
} // namespace zweek
